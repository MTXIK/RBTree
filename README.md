# Красно-черное дерево (RBTree)

## Описание

Данная программа реализует **красно-черное дерево** — сбалансированную структуру данных, которая обеспечивает эффективные операции вставки, удаления и поиска элементов. Программа демонстрирует работу с деревом, позволяя пользователю выполнять различные операции через удобный интерфейс. Каждая операция сопровождается измерением времени выполнения для оценки производительности.

### Основные возможности программы:

1. **Поиск элемента** в дереве.
2. **Вставка элемента** в дерево.
3. **Удаление элемента** из дерева.
4. **Получение 10 наименьших элементов** в дереве.
5. **Графический вывод структуры дерева** с возможностью ограничения глубины.
6. **Измерение времени выполнения** каждой из операций.

## Требования

- **Компилятор C++**: Поддерживающий стандарт C++11 или выше (например, `g++`, `clang++`).
- **Операционная система**: Windows, Linux, macOS или любая другая ОС с поддержкой C++.
- **Библиотеки**: Стандартная библиотека C++.

## Сборка

1. **Скачайте исходный код** программы и сохраните его в файл, например, `RBTree.cpp`.

2. **Откройте терминал** или командную строку и перейдите в директорию с исходным кодом.

3. **Скомпилируйте программу** с помощью компилятора C++. Например, используя `g++`:

   ```bash
   g++ -std=c++11 -o RBTree RBTree.cpp
   ```

   Где `RBTree.cpp` — имя файла с исходным кодом, а `RBTree` — имя создаваемого исполняемого файла.

## Использование

Запустите программу, передав в качестве обязательного аргумента имя входного бинарного файла. Опционально можно указать имя выходного файла с помощью ключа `-o`. Если имя выходного файла не указано, результаты записываются в файл `output.txt` по умолчанию.

### Синтаксис

```bash
./RBTree <input_file.bin> [-o <output_file.txt>]
```

- `<input_file.bin>`: Имя входного бинарного файла, содержащего список элементов для построения дерева.
- `-o <output_file.txt>`: (Опционально) Имя выходного текстового файла. Если ключ `-o` не указан, результаты записываются в файл `output.txt` по умолчанию.

### Пример использования

**Без указания выходного файла (результаты будут записаны в `output.txt`):**

```bash
./RBTree elements.bin
```

**С указанием выходного файла:**

```bash
./RBTree elements.bin -o results.txt
```

### Интерфейс пользователя

После запуска программы пользователю предоставляется меню с доступными операциями:

```
Выберите операцию:
1. Поиск
2. Вставка
3. Удаление
4. Получить 10 наименьших элементов
5. Вывести дерево
6. Выход
Ваш выбор: 
```

#### Описание операций:

1. **Поиск элемента**:
   - Запрашивает у пользователя значение элемента для поиска.
   - Выполняет поиск и сообщает о результате.
   - Выводит время выполнения операции.

2. **Вставка элемента**:
   - Запрашивает у пользователя значение элемента для вставки.
   - Вставляет элемент в дерево.
   - Выводит время выполнения операции.

3. **Удаление элемента**:
   - Запрашивает у пользователя значение элемента для удаления.
   - Удаляет элемент из дерева (если он существует).
   - Выводит время выполнения операции.

4. **Получить 10 наименьших элементов**:
   - Извлекает и отображает 10 наименьших элементов в дереве.
   - Выводит время выполнения операции.

5. **Вывести дерево**:
   - Запрашивает у пользователя максимальную глубину для вывода (можно ввести `-1` для полного вывода).
   - Отображает структуру дерева в консоли с указанным ограничением глубины.

6. **Выход**:
   - Завершает работу программы.

## Формат входного файла

Входной файл должен быть бинарным и содержать список элементов графа с 32-битными целыми числами (`int32`). Структура файла следующая:

1. **Первое число (`int32`)**: Количество элементов `n` для вставки в дерево.
2. **Далее следует `n` чисел (`int32`)**: Значения элементов для построения дерева.

### Пример создания бинарного файла

Вот пример того, как можно создать бинарный файл с элементами на языке C++:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <cstdint>

int main() {
    int32_t numElements = 15; // Число элементов

    // Список элементов для вставки
    std::vector<int32_t> elements = {
        20, 15, 25, 10, 18, 22, 30, 5, 12, 17,
        19, 21, 23, 28, 35
    };

    std::ofstream outFile("elements.bin", std::ios::binary);
    if (!outFile) {
        std::cerr << "Не удалось открыть файл для записи." << std::endl;
        return 1;
    }

    outFile.write(reinterpret_cast<char*>(&numElements), sizeof(numElements));
    outFile.write(reinterpret_cast<char*>(elements.data()), elements.size() * sizeof(int32_t));

    outFile.close();
    std::cout << "Бинарный файл elements.bin успешно создан." << std::endl;

    return 0;
}
```

Этот код создаст бинарный файл `elements.bin`, содержащий 15 элементов для построения красно-черного дерева.

## Формат выходного файла

Выходной файл представляет собой текстовый файл, содержащий результаты выполнения операций над деревом. В зависимости от выбранных операций, файл может содержать следующую информацию:

### Пример выходного файла

```
a) Мосты и точки сочленения:
Точки сочленения:
1 2

Мосты:
(1, 3) (2, 4)

b) Компоненты двусвязности:
Компонента 1:
(0, 1) (1, 2) 
Компонента 2:
(1, 3) (2, 3) (2, 4) 

c) Компоненты связности:
Компонента 1: 0 1 2 3 4 
```

*Примечание: Пример приведен для программы анализа связности графа. Для RBTree выходной файл будет содержать результаты операций поиска, вставки, удаления и т.д.*

### Ожидаемый формат для RBTree

В соответствии с предоставленным кодом, выходной файл будет содержать результаты операций, выполненных пользователем через интерфейс. Например:

```
Поиск элемента:
Элемент найден в дереве.
Время операции: 0.000123 секунд

Вставка элемента:
Элемент вставлен.
Время операции: 0.000456 секунд

Удаление элемента:
Элемент удален (если он существовал).
Время операции: 0.000789 секунд

Получение 10 наименьших элементов:
10 наименьших элементов: 5 10 12 15 17 18 19 20 21 22 
Время операции: 0.001234 секунд

Вывод дерева:
Структура дерева:
├── 15 (B)
│   ├── 10 (R)
│   │   └── 5 (B)
│   └── 20 (R)
│       ├── 18 (B)
│       └── 25 (B)
│           ├── 22 (R)
│           └── 30 (R)
```

## Функциональность

- **Чтение из файла**: Программа открывает бинарный файл, считывает количество элементов и сам список элементов, строя красно-черное дерево.
  
- **Поиск элемента**: Позволяет пользователю искать элемент в дереве, сообщает о результате и выводит время выполнения операции.
  
- **Вставка элемента**: Позволяет пользователю вставлять новый элемент в дерево, обеспечивает балансировку дерева и выводит время выполнения операции.
  
- **Удаление элемента**: Позволяет пользователю удалять существующий элемент из дерева, обеспечивает балансировку дерева и выводит время выполнения операции.
  
- **Получение 10 наименьших элементов**: Извлекает и отображает 10 наименьших элементов в дереве, используя инфиксный обход, и выводит время выполнения операции.
  
- **Графический вывод дерева**: Отображает структуру дерева в консоли с возможностью ограничения глубины вывода для удобства визуализации.

- **Измерение времени выполнения**: Для каждой операции программа измеряет и выводит время её выполнения с высокой точностью.

- **Освобождение памяти**: После завершения работы программа корректно освобождает всю выделенную динамическую память для предотвращения утечек памяти.

## Алгоритмы

### Красно-черное дерево

Красно-черное дерево — это разновидность самобалансирующихся бинарных деревьев поиска, которые гарантируют, что операции вставки, удаления и поиска выполняются за время \(O(\log n)\) в худшем случае. Основные свойства красно-черного дерева:

1. Каждый узел окрашен либо в красный, либо в черный цвет.
2. Корень дерева всегда черный.
3. Все листья (NIL-узлы) черные.
4. Если узел красный, то оба его дочерних узла черные.
5. Для каждого узла все пути от этого узла до листьев содержат одинаковое количество черных узлов.

### Операции над красно-черным деревом

- **Вставка**: Добавляет новый элемент в дерево, сохраняя его свойства путем применения поворотов и смены цветов.
  
- **Удаление**: Удаляет существующий элемент из дерева, обеспечивая сохранение его свойств через корректировки структуры и цветов узлов.
  
- **Поиск**: Находит элемент в дереве, используя свойства бинарного поиска.

- **Инфиксный обход**: Используется для извлечения элементов в отсортированном порядке, что позволяет легко получать наименьшие элементы.

## Тесты

Тестовые файлы находятся в папке `tests`. В этой папке вы найдете примеры бинарных файлов с различными наборами элементов для построения и тестирования красно-черного дерева. Эти тесты помогут проверить корректность работы программы.

### Пример использования тестов

1. **Перейдите в папку с тестами:**

   ```bash
   cd tests
   ```

2. **Создайте бинарный файл с элементами для теста (если он еще не создан):**

   Используйте предоставленный выше пример создания бинарного файла на C++.

3. **Запустите программу с одним из тестовых файлов:**

   ```bash
   ../RBTree test_elements.bin -o result1.txt
   ```

4. **Следуйте инструкциям программы для выполнения операций над деревом.**

5. **Просмотрите результаты в выходном файле:**

   ```bash
   cat result1.txt
   ```